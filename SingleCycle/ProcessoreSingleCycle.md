# Processore Single Cycle

## Stato architetturale
Lo stato architetturale del processore ARM è definito dal contenuto di 16 registri a 32 bit e di un registro di stato, quindi ogni microarchitettura ARM deve poter memorizzare per intero questo stato. A partire dallo stato architetturale corrente, il processore esegue una particolare istruzione su un insieme di dati per produrre un nuovo stato architetturale. Alcune architetture contengono anche uno stato supplementare, detto <b>stato non architetturale</b> che è utile a semplificare reti logiche o migliorare prestazioni.

## Progettazione del processore Single Cycle
Per semplicità si considera un processore in grado di eseguire un ristretto sottoinsieme di istruzioni ARM:
* Istruzioni di elaborazione <b> ADD, SUB, AND, ORR</b>.
* Istruzioni di accesso a memoria <b> LDR, STR</b> (con immediato positivo).
* Istruzione di salto <b>B</b>.

### <b>Data path e Control path</b>
Suddividiamo le microarchitetture in <b>percorso dati (data path)</b> e <b>unità di controllo (control unit o control path)</b>.  Il percorso dati opera su parole di dati a 32 bit e svolge le operazioni su essi, mentre l'unità di controllo riceve l'istruzione corrente dal data path e comunica ad esso come deve eseguirla, attivando opportuni ingressi di controllo ai componenti. <br>
Si parte dall'hardware necessario per gli elementi di stato, che includono memorie e stato architetturale (PC, registri, registro di stato). Si aggiungono poi i blocchi di logica combinatoria tra gli elementi di stato per generare il nuovo stato a partire da quello corrente.<br>
Abbiamo una <b>memoria istruzioni</b> da cui vengono lette le istruzioni da eseguire, e una <b>memoria dati</b> in cui vengono letti e scritti i dati. Inoltre abbiamo bisogno di un <b>banco di registri</b> su cui operiamo.<br>
Il <b>Program Counter</b> conviene realizzarlo come componente a parte perché viene aggiornato ad ogni ciclo di clock o in modo classico o da un'istruzione di salto. Quindi la sua uscita punta all'istruzione corrente e il suo ingresso all'istruzione successiva.<br>
La <b>memoria istruzioni</b> ha una sola porta di lettura, riceve in ingresso un indirizzo di istruzione a 32 bit ed emette su <b>RD</b> il dato a 32 bit che sarebbe l'istruzione.<br>
Il <b>banco di registri</b> ha 15 registri (r0-r14) più un ingresso per riscrivere il PC. Questo register file ha due porte di lettura che ricevono 2 indirizzi a 4 bit, <b>A1 e A2</b>, ciascuno dei quali specifica quale indirizzo selezionare come sorgente, ed emettono sulle uscite di lettura dati <b>RD1 e RD2</b> i valori a 32 bit dei registri indirizzati. La porta di scrittura invece riceve un indirizzo <b>A3</b> a 4 bit, un dato <b>WD3</b> a 32 bit e un segnale di abilitazione alla scrittura <b>WE3</b>, oltre naturalmente al segnale di <b>clock</b>. Una lettura in <b>r15</b> restituisce PC+8 e le scritture devono essere gestite qui sopra in modo particolare.<br>
La <b>memoria dati</b> ha una sola porta di lettura/scrittura. Se viene attivato il segnale <b>WE</b> allora il dato in ingresso <b>WD</b> viene scritto nella parola di indirizzo <b>A</b> in corrispondenza del fronte di salita del clock. Se il segnale di abilitazione alla scrittura vale 0, il contenuto della parola di indirizzo A viene emesso sull'uscita <b>RD</b>. Lo stato del sistema naturalmente si modifica solo in corrispondenza dei fronti di salita del ciclo di clock, quindi gli eventuali segnali vanno mandati prima della salita del clock e rimanere stabili.<br>
Fatte queste premesse bisogna ricordare che il processore Single Cycle non ha bisogno di stati non architetturali e che ha appunto un unico ciclo di clock in cui viene eseguita un'istruzione, che deve quindi essere tarato sull'istruzione più lunga in termini di tempo.

## Sviluppo del percorso dati
Per prima cosa abbiamo bisogno di un registro a 32 bit che contenga l'indirizzo dell'istruzione corrente (<b>PC</b>), che come ingressi prenda PC' e il ciclo di clock e fornisca in uscita l'indirizzo corrente PC. <br>
Possiamo ora passare alla progettazione della <b>memoria istruzioni</b>, che contiene in input il solo indirizzo A e in output l'uscita di lettura RD, rispettivamente indirizzo e istruzione.<br>
Proseguiamo poi a creare il nostro <b>banco di registri</b>, che sarebbe un vettore di 16 registri che ha come ingressi 2 indirizzi a 4 bit per i sorgenti, un indirizzo a 4 bit per il destinazione, il dato da scrivere eventualmente, il segnale di clock e il segnale di write-enable ed infine il valore del program counter opportunamente incrementato. In uscita invece ha le letture rispettive delle sorgenti RD1 e RD2.<br> 
Infine costruiamo la <b>memoria dati</b>, che rappresenta in qualche modo la memoria centrale, dalla quale è possibile leggere un dato da inserire in un registro, alla locazione <b>A</b> sull'uscita <b>RD</b>. È possibile naturalmente anche scriverci, un certo dato <b>WD</b> se il segnale <b>WE</b> è alto.<br>
### <b>LDR</b>
Per eseguire l'istruzione LDR, dopo la fase di fetch occorre leggere il registro sorgente contenente <b>l'indirizzo di base</b>. Tale registro è specificato dal campo <i>Rn</i> dell'istruzione ossia nei bit <code>[19:16]</code>. Questi bit vengono collegati agli ingressi di indirizzo di una delle porte del File Register, ossia la <b>A1</b> in quanto è l'indirizzo del primo sorgente. Quest'ultimo emette il valore letto su <b>RD1</b>.<br>
Nella LDR c'è anche uno spiazzamento nei bit <code>[11:0]</code> che si suppone positivo, che va però esteso a 32 bit con un opportuno <b>Extender</b>. <br>
Il processore deve poi sommare lo spiazzamento al registro di base per ottenere l'indirizzo di memoria da cui leggere il dato. Si introduce quindi una <b>ALU</b> che prende in ingresso SrcA e SrcB, da cui il primo arriva dal banco di registri e il secondo dall'estensore. L'alu prende anche un segnale di controllo a 2 bit che specifica le operazioni che può fare. (00 -> somma). L'output della ALU è un'uscita a 32 bit <b>ALUResult</b> che verrà usata come indirizzo con cui leggere dalla memoria dati.<br>
Il dato emesso dalla memoria dati viene emesso sul bus <b>ReadData</b> e scritto nel registro destinazione alla fine del ciclo (<b>WRITEBACK</b>).<br>
Mentre viene eseguita l'istruzione, il processore deve anche calcolare l'indirizzo della posizione successiva PC'. Siccome le istruzioni sono a 32 bit (4 byte) l'istruzione successiva si trova a PC + 4. Costruiamoci una piccola ALU che incrementa il PC di 4.<br>
Nell'architettura ARM leggere dal registro <b>R15</b> restituisce PC + 8, quindi occorre un ulteriore sommatore per incrementare ulteriormente il PC e passarlo all'ingresso R15. Tuttavia, scrivere in R15 significa anche <b>modificare il PC</b>, quindi il risultato di PC può venire dalla memoria invece che da PC + 4. Occorre quindi un multiplexer per scegliere tra le due possibilità, con un segnale <b>PCSrc</b> posto a 0 se si incrementa di 4 e a 1 altrimenti.<br>
### <b>STR</b>
A questo punto si può estendere il percorso dati per gestire la STR, che analogamente a LDR legge un indirizzo base alla porta <b>A1</b> del banco di registri ed estende a 32 bit l'immediato. Una cosa che fa in più è leggere anche un secondo registro dal register file per scriverlo nella memoria dati: Il registro è specificato in <b>Rd</b> e quindi disponibile nei bit <code>[15:12]</code> collegati ad <b>A2</b>. Il valore di tale registro viene emesso su <b>RD2</b>, collegata alla porta di scrittura <b>WD</b> della memoria dati. Il segnale <b>MemWrite</b> controlla il <b>WE</b>, ossia deve essere 1 per scrivere e 0 altrimenti. Inoltre il controllo <b>RegWrite</b> deve essere 0 perché non si deve scrivere nulla nei registri. 
### <b>Elaborazione dati (ADD,SUB, AND, ORR)</b>
Anzitutto va aggiunto nella ALU un nuovo output a 4 bit che andrà nella parte di controllo, contenente i flag <b>Zero, Negative, Carry, oVerflow</b>. Siccome poi questo tipo di istruzioni usa un immediato da 8 bit e non da 12 bit, va anche aggiunto il segnale ImmSrc al blocco dell'estensore, di modo da scegliere in che tipo di istruzione ci troviamo.<br>
Un'ulteriore cambiamento sta nel fatto che, a differenza della LDR, noi non andiamo a prendere il dato dalla memoria dati bensì dal risultato della ALU, quindi serve un altro multiplexer per scegliere tra <b>ReadData</b> e <b>ALUResult</b>, pilotato dal segnale <b>MemtoReg</b>.<br>
Inoltre se volessimo sommare il valore di due registri piuttosto che di un registro e un immediato, dovremmo poterci scegliere il <b>Rm</b> (nei bit <code>[3:0]</code>). Questo viene fatto con un ulteriore segnale <b>RegSrc</b> a un multiplexer. <br>
In maniera simile, anche prima della ALU ci serve sapere se pescare il valore di <b>WriteData</b> oppure dell'immediato, e inseriamo un nuovo multiplexer controllato dal segnale <b>ALUSrc</b>.
### <b> Salti B</b>
Infine si gestiscono i salti, in questo caso salti normali B. L'istruzione in particolare deve sommare un immediato a 24 bit a PC + 8, e scrive il risultato nel <b>PC</b>. L'immediato deve essere moltiplicato per 4 ed esteso a 32 bit con segno. Estendiamo il segnale <b>ImmSrc</b> a 2 bit per gestire i 2 tipi di istruzioni e aggiungiamo un multiplexer che sceglie <b>R15</b> come ingresso <b>RA1</b>, pilotato da un altro bit di <b>RegSrc</b>.

## Sviluppo dell'unità di controllo
L'unità di controllo genera i segnali sulla base dei campi <b>cond, op e funct</b> dell'istruzione (<code>[31:28], [27:26], [25:20]</code>) e dei flag in uscita della ALU, tenendo conto anche di se il Destination Register è o meno il PC. <br>
Suddividiamo in due parti l'unità di controllo: il <b>Decoder</b>, che genera i segnali di controllo in base all'istruzione, e la <b>Logica Condizionale</b> che mantiene i flag di stato e abilita gli aggiornamenti dello stato architetturale.<br> Il <b>Decoder</b> è suddiviso a sua volta in <b>Decoder principale</b>, che determina il tipo di istruzione: operativa, memoria, salto, generando gli opportuni segnali di controllo. Manda <b>MemtoReg, ALUSrc, ImmSrc e RegSrc</b> direttamente al percorso dati, mentre le abilitazioni alla scrittura <b>MemW e RegW</b> devono prima passare nella logica condizionale per poi diventare <b>MemWrite e RegWrite</b>. Il Decoder Principale genera anche i segnali di <b>Branch e ALUOp</b> all'interno dell'unità di controllo usati per indicare se l'istruzione è un salto o un'operativa. La parte del <b>Decoder</b> è quindi una semplice rete combinatoria, suddivisa in 3 pezzi: <b>Decoder principale, Logica del PC, Decoder dell'ALU</b>.